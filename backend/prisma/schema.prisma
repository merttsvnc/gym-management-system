// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
}

// Role enum
enum Role {
  ADMIN
  // Future: OWNER, STAFF, TRAINER, ACCOUNTANT
}

// Plan enum
enum PlanKey {
  SINGLE
}

// Member status enum
enum MemberStatus {
  ACTIVE
  PAUSED
  INACTIVE
  ARCHIVED
}

// Member gender enum
enum MemberGender {
  MALE
  FEMALE
}

// Marital status enum
enum MaritalStatus {
  SINGLE
  MARRIED
  DIVORCED
  WIDOWED
  OTHER
}

// Blood type enum
enum BloodType {
  A_POS
  A_NEG
  B_POS
  B_NEG
  AB_POS
  AB_NEG
  O_POS
  O_NEG
  UNKNOWN
}

// Duration type enum for membership plans
enum DurationType {
  DAYS
  MONTHS
}

// Plan status enum
enum PlanStatus {
  ACTIVE
  ARCHIVED
}

// Plan scope enum
enum PlanScope {
  TENANT
  BRANCH
}

// Billing status enum
enum BillingStatus {
  TRIAL
  ACTIVE
  PAST_DUE
  SUSPENDED
}

// Payment method enum
enum PaymentMethod {
  CASH
  CREDIT_CARD
  BANK_TRANSFER
  CHECK
  OTHER
}

// Tenant model
model Tenant {
  id                     String        @id @default(cuid())
  name                   String
  slug                   String        @unique
  defaultCurrency        String        @default("USD")
  timezone               String        @default("Europe/Istanbul") // IANA timezone for business-day grouping in reports
  planKey                PlanKey       @default(SINGLE)
  billingStatus          BillingStatus @default(TRIAL)
  billingStatusUpdatedAt DateTime?
  trialStartedAt         DateTime?
  trialEndsAt            DateTime?
  createdAt              DateTime      @default(now())
  updatedAt              DateTime      @updatedAt

  // Relations
  branches          Branch[]
  users             User[]
  members           Member[]
  membershipPlans   MembershipPlan[]
  payments          Payment[]
  planChangeHistory MemberPlanChangeHistory[]
  products          Product[]
  productSales      ProductSale[]

  @@index([slug])
  @@index([billingStatus])
}

// ============================================================
// Tenant Isolation Enforcement
// ------------------------------------------------------------
// @@unique([id, tenantId]) enables composite where usage:
//
// where: { id_tenantId: { id, tenantId } }
//
// This enforces tenant scoping at DB level for update/delete.
// Branch-scoped models use:
//
// @@unique([id, tenantId, branchId])
//
// Do NOT remove these constraints unless the service layer
// is redesigned accordingly.
// ============================================================

// Branch model
model Branch {
  id         String    @id @default(cuid())
  tenantId   String
  name       String
  address    String
  isDefault  Boolean   @default(false)
  isActive   Boolean   @default(true)
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  archivedAt DateTime?

  // Relations
  tenant          Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  members         Member[]
  membershipPlans MembershipPlan[]
  payments        Payment[]
  products        Product[]
  productSales    ProductSale[]

  @@unique([tenantId, name])
  @@unique([id, tenantId])
  @@index([tenantId])
  @@index([tenantId, isActive])
  @@index([tenantId, isDefault])
}

// User model
model User {
  id             String    @id @default(cuid())
  tenantId       String
  email          String    @unique
  passwordHash   String
  firstName      String
  lastName       String
  role           Role      @default(ADMIN)
  isActive       Boolean   @default(true)
  emailVerifiedAt DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  // Relations
  tenant               Tenant                    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  scheduledPlanChanges Member[]                  @relation("ScheduledByUser")
  planChangeHistory    MemberPlanChangeHistory[]
  passwordResetOtps    PasswordResetOtp[]

  @@index([tenantId])
  @@index([email])
}

// MembershipPlan model
model MembershipPlan {
  id            String       @id @default(cuid())
  tenantId      String
  scope         PlanScope    @default(TENANT)
  branchId      String?
  scopeKey      String       @default("TENANT")
  name          String
  description   String?
  durationType  DurationType
  durationValue Int
  price         Decimal      @db.Decimal(10, 2)
  currency      String
  maxFreezeDays Int?
  autoRenew     Boolean      @default(false)
  status        PlanStatus
  archivedAt    DateTime?
  sortOrder     Int?
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  tenant         Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch         Branch?  @relation(fields: [branchId], references: [id], onDelete: Restrict)
  members        Member[]
  pendingMembers Member[] @relation("PendingMembershipPlan")

  @@unique([tenantId, scope, scopeKey, name])
  @@unique([id, tenantId])
  @@index([tenantId])
  @@index([tenantId, scope])
  @@index([tenantId, status])
  @@index([tenantId, scope, status])
  @@index([tenantId, branchId])
  @@index([branchId])
  @@index([tenantId, sortOrder])
  @@index([tenantId, archivedAt])
  @@index([tenantId, archivedAt, status])
}

// Member model
model Member {
  id       String @id @default(cuid())
  tenantId String
  branchId String

  // Core profile fields
  firstName   String
  lastName    String
  gender      MemberGender?
  dateOfBirth DateTime?
  phone       String
  email       String?
  photoUrl    String?

  // Extended profile fields
  address               String?
  district              String?
  nationalId            String?
  maritalStatus         MaritalStatus?
  occupation            String?
  industry              String?
  bloodType             BloodType?
  emergencyContactName  String?
  emergencyContactPhone String?

  // Membership information
  membershipPlanId          String
  membershipStartDate       DateTime
  membershipEndDate         DateTime
  membershipPriceAtPurchase Decimal? @db.Decimal(10, 2)

  // Pending membership plan change (scheduled for period end)
  pendingMembershipPlanId            String?
  pendingMembershipStartDate         DateTime?
  pendingMembershipEndDate           DateTime?
  pendingMembershipPriceAtPurchase   Decimal?  @db.Decimal(10, 2)
  pendingMembershipScheduledAt       DateTime?
  pendingMembershipScheduledByUserId String?

  // Status
  status    MemberStatus @default(ACTIVE)
  pausedAt  DateTime?
  resumedAt DateTime?

  // Notes
  notes String?

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  tenant                       Tenant                    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch                       Branch                    @relation(fields: [branchId], references: [id], onDelete: Restrict)
  membershipPlan               MembershipPlan            @relation(fields: [membershipPlanId], references: [id])
  pendingMembershipPlan        MembershipPlan?           @relation("PendingMembershipPlan", fields: [pendingMembershipPlanId], references: [id])
  pendingMembershipScheduledBy User?                     @relation("ScheduledByUser", fields: [pendingMembershipScheduledByUserId], references: [id])
  payments                     Payment[]
  planChangeHistory            MemberPlanChangeHistory[]

  @@unique([tenantId, phone])
  @@unique([id, tenantId])
  @@index([tenantId, branchId])
  @@index([tenantId, phone])
  @@index([membershipPlanId])
  @@index([tenantId, membershipPlanId])
  @@index([tenantId, nationalId])
  @@index([tenantId, emergencyContactPhone])
  @@index([tenantId, pendingMembershipPlanId])
  @@index([tenantId, pendingMembershipStartDate])
}

// Payment model
// AUDIT TRAIL DESIGN:
// - Original payments can have MULTIPLE corrections (no unique constraint on correctedPaymentId)
// - Each correction points to the original via correctedPaymentId
// - Original payment's isCorrected flag tracks "has been corrected at least once"
// - To find all corrections for payment A: query where correctedPaymentId = A.id
// - Revenue reports exclude corrections by filtering: isCorrection = false
model Payment {
  id       String @id @default(cuid())
  tenantId String
  branchId String
  memberId String

  // Payment details
  amount        Decimal       @db.Decimal(10, 2)
  paidOn        DateTime // DATE-ONLY business date: stored as DateTime set to start-of-day UTC (00:00:00Z); tenant timezone used for date selection/display
  paymentMethod PaymentMethod
  note          String?       @db.VarChar(500)

  // Correction tracking (audit trail: multiple corrections allowed per original payment)
  isCorrection       Boolean @default(false)
  correctedPaymentId String? // FK to original payment being corrected (no @unique = many corrections per original)
  isCorrected        Boolean @default(false)

  // Optimistic locking
  version Int @default(0)

  // Audit fields (strictly for audit, not business logic)
  createdBy String // User ID
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  tenant             Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch             Branch    @relation(fields: [branchId], references: [id], onDelete: Restrict)
  member             Member    @relation(fields: [memberId], references: [id], onDelete: Restrict)
  correctedPayment   Payment?  @relation("PaymentCorrection", fields: [correctedPaymentId], references: [id], onDelete: SetNull)
  correctingPayments Payment[] @relation("PaymentCorrection") // One-to-many: original payment can have multiple corrections

  @@unique([id, tenantId])
  @@index([tenantId])
  @@index([tenantId, branchId])
  @@index([tenantId, memberId])
  @@index([tenantId, paidOn])
  @@index([tenantId, paymentMethod])
  @@index([tenantId, paidOn, branchId])
  @@index([tenantId, paidOn, paymentMethod])
  @@index([memberId])
  @@index([branchId])
  @@index([correctedPaymentId])
  @@index([tenantId, isCorrection])
  @@index([tenantId, isCorrected])
}

// IdempotencyKey model (for idempotency support)
model IdempotencyKey {
  id        String   @id @default(cuid())
  key       String   @unique
  tenantId  String
  userId    String
  response  Json // Cached response
  createdAt DateTime @default(now())
  expiresAt DateTime // TTL: 24 hours

  @@index([key])
  @@index([expiresAt]) // For cleanup job
}

// MemberPlanChangeHistory model (audit trail for plan changes)
model MemberPlanChangeHistory {
  id       String @id @default(cuid())
  tenantId String
  memberId String

  // Plan change details
  oldPlanId          String?
  newPlanId          String?
  oldStartDate       DateTime?
  oldEndDate         DateTime?
  newStartDate       DateTime?
  newEndDate         DateTime?
  oldPriceAtPurchase Decimal?  @db.Decimal(10, 2)
  newPriceAtPurchase Decimal?  @db.Decimal(10, 2)

  // Change tracking
  changeType      String // "SCHEDULED" | "APPLIED" | "CANCELLED"
  scheduledAt     DateTime?
  appliedAt       DateTime?
  changedByUserId String?

  // Timestamps
  createdAt DateTime @default(now())

  // Relations
  tenant        Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  member        Member @relation(fields: [memberId], references: [id], onDelete: Cascade)
  changedByUser User?  @relation(fields: [changedByUserId], references: [id])

  @@index([tenantId, memberId])
  @@index([tenantId, appliedAt])
  @@index([tenantId, scheduledAt])
  @@index([memberId])
}

// EmailOtp model (for email verification during signup)
model EmailOtp {
  id            String    @id @default(cuid())
  email         String
  otpHash       String    // Hashed OTP (never store plain)
  expiresAt     DateTime
  attemptCount  Int       @default(0)
  consumedAt    DateTime?
  lastSentAt    DateTime  @default(now())
  dailySentCount Int      @default(0)
  dailySentAt   DateTime?
  createdAt     DateTime  @default(now())

  @@index([email])
  @@index([email, consumedAt])
  @@index([email, expiresAt])
}

// PasswordResetOtp model (for password reset via email OTP)
model PasswordResetOtp {
  id            String    @id @default(cuid())
  userId        String    // FK to User
  otpHash       String    // Hashed OTP (never store plain)
  expiresAt     DateTime
  attemptCount  Int       @default(0)
  lastSentAt    DateTime  @default(now())
  dailySentCount Int      @default(0)
  dailySentAt   DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, expiresAt])
  @@index([userId, createdAt])
}

// Product model (for in-gym product catalog: tea, coffee, gloves, etc.)
model Product {
  id           String   @id @default(cuid())
  tenantId     String
  branchId     String
  name         String
  defaultPrice Decimal  @db.Decimal(12, 2)
  category     String?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  tenant    Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch    Branch            @relation(fields: [branchId], references: [id], onDelete: Restrict)
  saleItems ProductSaleItem[]

  @@unique([id, tenantId, branchId])
  @@index([tenantId, branchId])
  @@index([tenantId, branchId, isActive])
}

// ProductSale model (represents a complete sale transaction)
model ProductSale {
  id              String        @id @default(cuid())
  tenantId        String
  branchId        String
  soldAt          DateTime // Business date/time when sale occurred
  paymentMethod   PaymentMethod
  note            String?       @db.VarChar(500)
  totalAmount     Decimal       @db.Decimal(12, 2)
  createdByUserId String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  tenant Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch Branch            @relation(fields: [branchId], references: [id], onDelete: Restrict)
  items  ProductSaleItem[]

  @@unique([id, tenantId, branchId])
  @@index([tenantId, branchId, soldAt])
  @@index([tenantId, branchId, createdAt])
  @@index([tenantId, soldAt])
}

// ProductSaleItem model (line items for each sale)
// Business rule: Exactly one of (productId, customName) must be provided
model ProductSaleItem {
  id         String   @id @default(cuid())
  saleId     String
  tenantId   String
  branchId   String
  productId  String? // FK to Product (nullable for custom items)
  customName String? // Free-text name for non-catalog items (nullable for catalog items)
  quantity   Int
  unitPrice  Decimal  @db.Decimal(12, 2) // Snapshot at time of sale
  lineTotal  Decimal  @db.Decimal(12, 2) // quantity * unitPrice
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  sale    ProductSale @relation(fields: [saleId], references: [id], onDelete: Cascade)
  product Product?    @relation(fields: [productId], references: [id], onDelete: Restrict)

  @@index([tenantId, branchId])
  @@index([saleId])
  @@index([productId])
  @@index([tenantId, saleId])
}

// RevenueMonthLock model (prevents editing sales in locked months)
model RevenueMonthLock {
  id            String   @id @default(cuid())
  tenantId      String
  branchId      String
  month         String // Format: "YYYY-MM" (e.g., "2026-02")
  lockedAt      DateTime @default(now())
  lockedByUserId String?
  createdAt     DateTime @default(now())

  @@unique([tenantId, branchId, month])
  @@index([tenantId, branchId])
  @@index([tenantId, month])
}
